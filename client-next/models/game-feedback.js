const {
    GoogleGenerativeAI,
    HarmCategory,
    HarmBlockThreshold,
} = require("@google/generative-ai");

const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
const genAI = new GoogleGenerativeAI(apiKey);

const model = genAI.getGenerativeModel({
    model: "gemini-2.0-flash-exp",
});

const generationConfig = {
    temperature: 1,
    topP: 0.95,
    topK: 40,
    maxOutputTokens: 8192,
    responseMimeType: "application/json",
};


export const gameFeedback = model.startChat({
    generationConfig,
    history: [
        {
            role: "user",
            parts: [
                { text: "You are a coding interviewer judging an applicant's response for the following coding question. Give it a rating on a scale of 1 to 10. Take into account time complexity, space complexity, correct usage of data structures and algorithms, and thoroughness of the approach. Do not score generously, but be nice, uplifting, and encouraging in your feedback. An approach that does not work should be given a 1, while only an optimal response should be given a 10. For each piece of feedback, explain how the user could improve on their response. Feedback should be several sentences long. The applicant is not expected to provide code. Address the applicant as \"you\".\n\nTime complexity: whether the algorithm runs in the optimal time.\nSpace complexity: whether the algorithm uses minimal space.\nData structures and algorithms: whether the approach uses optimal data structures and algorithms in the solution.\nThoroughness: whether the response is thorough and complex, explaining the implementation in depth and explaining the time complexity, space complexity, and structures used to you in an understandable way. More detail is better. If the user does not explicitly state the time and space complexity of their algorithm, points should be taken off. If the user does not explain why their approach is the best approach or how it compares to other approaches, points should be taken off.\n\nThe coding question is as follows:\nYou are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\n\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\n\nThe user response is as follows:\nCreate a new array object the size of m + n, then use a two pointer approach to add the values from the original two arrays into the new array. Then store the final output into the first array.\n\nStore the output in a JSON format. Follow the following structure:\n{\nfinal_score: String,\nfeedback: String,\ntime_complexity: {\nscore: String,\nfeedback: String,\n},\nspace_complexity: {\nscore: String,\nfeedback: String,\n},\ndsa: {\nscore: String,\nfeedback: String,\n},\nexplanation: {\nscore: String,\nfeedback: String,\n}\n}" },
            ],
        },
        {
            role: "model",
            parts: [
                { text: "```json\n{\n\"final_score\": \"6\",\n\"feedback\": \"This is a decent start and you've identified a good approach using two pointers. However, there's room for improvement in terms of space complexity and thoroughness. While the two-pointer technique is correct for merging sorted arrays, you're not utilizing the fact that the result should be stored in-place within nums1, which means we can avoid using extra memory with a new array object. Let's break down how you can improve.\",\n\"time_complexity\": {\n\"score\": \"9\",\n\"feedback\": \"Your time complexity is excellent. The two-pointer approach will iterate over the elements of both arrays at most once, resulting in O(m+n) time, which is optimal for this problem.\"\n},\n\"space_complexity\": {\n\"score\": \"3\",\n\"feedback\": \"The space complexity of creating a new array object of size m+n is O(m+n), which is not ideal. You can do better by merging in-place using the space already provided in nums1. Aim to use a constant amount of extra space, or O(1).\"\n},\n\"dsa\": {\n\"score\": \"7\",\n\"feedback\": \"Your choice of using two pointers is good, as it's an efficient algorithm for merging sorted arrays. However, you could improve by considering how to merge in-place instead of creating a new array. The 'merge in place' algorithm using the two-pointer technique is the optimal approach. \"\n},\n\"explanation\": {\n\"score\": \"5\",\n\"feedback\": \"Your explanation is a good start, but it's not very thorough. You need to mention time and space complexities explicitly and how your chosen approach compares with other approaches. Also, you're missing a key detail: how to merge in-place within `nums1`. This implies that you may be thinking of creating a separate output array then copying it into the first array, which is suboptimal. You also should mention that you're merging from the back of the array. Let's try to be as thorough as possible to maximize points next time!\"\n}\n}\n```\n" },
            ],
        },
        {
            role: "user",
            parts: [
                { text: "You are a coding interviewer judging an applicant's response for the following coding question. Give it a rating on a scale of 1 to 10. Take into account time complexity, space complexity, correct usage of data structures and algorithms, and thoroughness of the approach. Do not score generously, but be nice, uplifting, and encouraging in your feedback. An approach that does not work should be given a 1, while only an optimal response should be given a 10. For each piece of feedback, explain how the user could improve on their response. Feedback should be several sentences long. The applicant is not expected to provide code. Address the applicant as \"you\".\n\nTime complexity: whether the algorithm runs in the optimal time.\nSpace complexity: whether the algorithm uses minimal space.\nData structures and algorithms: whether the approach uses optimal data structures and algorithms in the solution.\nThoroughness: whether the response is thorough and complex, explaining the implementation in depth and explaining the time complexity, space complexity, and structures used to you in an understandable way. More detail is better. If the user does not explicitly state the time and space complexity of their algorithm, points should be taken off. If the user does not explain why their approach is the best approach or how it compares to other approaches, points should be taken off.\n\nThe coding question is as follows:\nGiven an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.\\n\\nConstraints:\\n2 <= nums.length <= 10^4\\n-10^9 <= nums[i] <= 10^9\\n-10^9 <= target <= 10^9\\nOnly one valid answer exists.\n\nThe user response is as follows:\nUse a nested for loop to check each item in the first and second array to see if a solution exists. This would be an O(n^4) algorithm. The space complexity would be O(2^n). This would be better than other algorithms because it uses only a native array.\n\nStore the output in a JSON format. Follow the following structure:\n{\nfinal_score: String,\nfeedback: String,\ntime_complexity: {\nscore: String,\nfeedback: String,\n},\nspace_complexity: {\nscore: String,\nfeedback: String,\n},\ndsa: {\nscore: String,\nfeedback: String,\n},\nexplanation: {\nscore: String,\nfeedback: String,\n}\n}" },
            ],
        },
        {
            role: "model",
            parts: [
                { text: "```json\n{\n\"final_score\": \"1\",\n\"feedback\": \"Unfortunately, this is not a good approach and has several critical issues. Let's break down where things went wrong and how you can improve. Your stated time complexity and space complexity are also incorrect, so let's clarify all of those points.\",\n  \"time_complexity\": {\n    \"score\": \"1\",\n    \"feedback\": \"Your claim of O(n^4) time complexity is inaccurate. With a nested for loop iterating through a single array, the time complexity will be O(n^2), not O(n^4). But even that is still not optimal. The correct algorithm should be O(n). We can do much better here. \"\n  },\n  \"space_complexity\": {\n    \"score\": \"1\",\n    \"feedback\": \"Your stated space complexity of O(2^n) is also incorrect. A nested for loop does not use additional space that grows exponentially with the input size. If no additional space is being used other than to store the indices of the answer, it would be O(1). Other solutions that use a hashmap will have a space complexity of O(n). Neither of these options are O(2^n). Therefore, this is incorrect.\"\n  },\n  \"dsa\": {\n    \"score\": \"1\",\n    \"feedback\": \"The nested for loop approach is extremely inefficient for this problem. It's not the right algorithm or data structure. There are much better approaches to solving this problem with either a hashmap or a single loop with an auxiliary space.\"\n  },\n  \"explanation\": {\n    \"score\": \"1\",\n    \"feedback\": \"Your explanation is flawed in several places. First, you are not using two arrays. The problem specifies only a single array, so it's not clear where the idea of the second array is coming from. Second, your time complexity and space complexity calculations are incorrect. Also, your claim that this is better than other algorithms because it only uses a native array is also incorrect. Other algorithms can also use only a native array and have better performance in both time and space complexity. Finally, the correct solution does not require checking all pairs of numbers, so the nested loops are inefficient. You also didn't specify the algorithm or data structures you should be using in the correct algorithm. The most important thing you can do to improve here is to learn other solutions and do more problem practice. Keep practicing and you'll get better!\"\n  }\n}\n```\n" },
            ],
        },
    ],
});
